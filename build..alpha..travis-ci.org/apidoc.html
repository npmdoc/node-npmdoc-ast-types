<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://github.com/benjamn/ast-types"

    >ast-types (v0.9.11)</a>
</h1>
<h4>Esprima-compatible implementation of the Mozilla JS Parser API</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types">module ast-types</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath">
            function <span class="apidocSignatureSpan">ast-types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path">
            function <span class="apidocSignatureSpan">ast-types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor">
            function <span class="apidocSignatureSpan">ast-types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type">
            function <span class="apidocSignatureSpan">ast-types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">ast-types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.defineMethod">
            function <span class="apidocSignatureSpan">ast-types.</span>defineMethod
            <span class="apidocSignatureSpan">(name, func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.eachField">
            function <span class="apidocSignatureSpan">ast-types.</span>eachField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.finalize">
            function <span class="apidocSignatureSpan">ast-types.</span>finalize
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.getFieldNames">
            function <span class="apidocSignatureSpan">ast-types.</span>getFieldNames
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.getFieldValue">
            function <span class="apidocSignatureSpan">ast-types.</span>getFieldValue
            <span class="apidocSignatureSpan">(object, fieldName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.getSupertypeNames">
            function <span class="apidocSignatureSpan">ast-types.</span>getSupertypeNames
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.someField">
            function <span class="apidocSignatureSpan">ast-types.</span>someField
            <span class="apidocSignatureSpan">(object, callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.use">
            function <span class="apidocSignatureSpan">ast-types.</span>use
            <span class="apidocSignatureSpan">(plugin)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.visit">
            function <span class="apidocSignatureSpan">ast-types.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>NodePath.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>Path.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>PathVisitor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>Type.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>builders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>builtInTypes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ast-types.</span>namedTypes</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.NodePath">module ast-types.NodePath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.NodePath">
            function <span class="apidocSignatureSpan">ast-types.</span>NodePath
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.NodePath.prototype">module ast-types.NodePath.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype._computeNode">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeNode
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype._computeParent">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeParent
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype._computeScope">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.canBeFirstInStatement">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>canBeFirstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.firstInStatement">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>firstInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.needsParens">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>needsParens
            <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.prune">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>prune
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.NodePath.prototype.replace">
            function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>replace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.Path">module ast-types.Path</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.Path">
            function <span class="apidocSignatureSpan">ast-types.</span>Path
            <span class="apidocSignatureSpan">(value, parentPath, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.Path.prototype">module ast-types.Path.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.each">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>each
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.filter">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>filter
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.get">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>get
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.getValueProperty">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>getValueProperty
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.insertAfter">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertAfter
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.insertAt">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertAt
            <span class="apidocSignatureSpan">(index, node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.insertBefore">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertBefore
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.map">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>map
            <span class="apidocSignatureSpan">(callback, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.pop">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.push">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>push
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.replace">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>replace
            <span class="apidocSignatureSpan">(replacement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.shift">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>shift
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Path.prototype.unshift">
            function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>unshift
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.PathVisitor">module ast-types.PathVisitor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.PathVisitor">
            function <span class="apidocSignatureSpan">ast-types.</span>PathVisitor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.fromMethodsObject">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.</span>fromMethodsObject
            <span class="apidocSignatureSpan">(methods)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.visit">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.</span>visit
            <span class="apidocSignatureSpan">(node, methods)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.PathVisitor.prototype">module ast-types.PathVisitor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.AbortRequest">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>AbortRequest
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.abort">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>abort
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.acquireContext">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>acquireContext
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.releaseContext">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>releaseContext
            <span class="apidocSignatureSpan">(context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.reportChanged">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>reportChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.reset">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>reset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.visit">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>visit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.visitWithoutReset">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>visitWithoutReset
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.PathVisitor.prototype.wasChangeReported">
            function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>wasChangeReported
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.Type">module ast-types.Type</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.Type">
            function <span class="apidocSignatureSpan">ast-types.</span>Type
            <span class="apidocSignatureSpan">(check, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.def">
            function <span class="apidocSignatureSpan">ast-types.Type.</span>def
            <span class="apidocSignatureSpan">(typeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.fromArray">
            function <span class="apidocSignatureSpan">ast-types.Type.</span>fromArray
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.fromObject">
            function <span class="apidocSignatureSpan">ast-types.Type.</span>fromObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.or">
            function <span class="apidocSignatureSpan">ast-types.Type.</span>or
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.Type.prototype">module ast-types.Type.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.prototype.arrayOf">
            function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>arrayOf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.prototype.assert">
            function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>assert
            <span class="apidocSignatureSpan">(value, deep)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.Type.prototype.toString">
            function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.astNodesAreEquivalent">module ast-types.astNodesAreEquivalent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.astNodesAreEquivalent.astNodesAreEquivalent">
            function <span class="apidocSignatureSpan">ast-types.</span>astNodesAreEquivalent
            <span class="apidocSignatureSpan">(a, b, problemPath)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.astNodesAreEquivalent.assert">
            function <span class="apidocSignatureSpan">ast-types.astNodesAreEquivalent.</span>assert
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ast-types.builders">module ast-types.builders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.anyTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>anyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrayExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrayPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrayStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrayTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrowFunctionExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrowFunctionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.arrowFunctionStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>arrowFunctionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.assignmentExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.assignmentPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.assignmentStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.awaitExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>awaitExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.awaitStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>awaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.binaryExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>binaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.binaryStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>binaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.bindExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>bindExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.bindStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>bindStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.block">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>block
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.blockStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>blockStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.booleanLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.booleanLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.booleanLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.booleanTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.breakStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>breakStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.callExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>callExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.callStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>callStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.catchClause">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>catchClause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classBody">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classBody
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classImplements">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classImplements
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classMethod">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classPropertyDefinition">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classPropertyDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.classStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>classStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.commentBlock">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>commentBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.commentLine">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>commentLine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.comprehensionBlock">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionBlock
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.comprehensionExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.comprehensionStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.conditionalExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>conditionalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.conditionalStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>conditionalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.continueStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>continueStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.debuggerStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>debuggerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareClass">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareClass
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareExportAllDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareExportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareExportDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareExportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareFunction">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareFunction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareInterface">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareModule">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareModule
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareModuleExports">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareModuleExports
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareTypeAlias">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareTypeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.declareVariable">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>declareVariable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.decorator">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>decorator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.directive">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>directive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.directiveLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>directiveLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.directiveLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>directiveLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.doExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>doExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.doStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>doStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.doWhileStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>doWhileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.emptyStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>emptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.emptyTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>emptyTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.existentialTypeParam">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>existentialTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.existsTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>existsTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportAllDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportAllDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportBatchSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportBatchSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportDefaultDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDefaultDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportDefaultSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportNamedDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportNamedDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportNamespaceSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.exportSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>exportSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.expressionStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>expressionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.file">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>file
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.forAwaitStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>forAwaitStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.forInStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>forInStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.forOfStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>forOfStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.forStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>forStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.functionDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>functionDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.functionExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>functionExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.functionStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>functionStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.functionTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>functionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.functionTypeParam">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>functionTypeParam
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.generatorExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>generatorExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.generatorStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>generatorStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.genericTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>genericTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.graphExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>graphExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.graphIndexExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>graphIndexExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.graphIndexStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>graphIndexStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.graphStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>graphStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.identifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>identifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.identifierStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>identifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.ifStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>ifStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.import">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>import
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.importDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>importDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.importDefaultSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>importDefaultSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.importNamespaceSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>importNamespaceSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.importSpecifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>importSpecifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.importStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>importStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.interfaceDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>interfaceDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.interfaceExtends">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>interfaceExtends
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.intersectionTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>intersectionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxAttribute">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxClosingElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxClosingElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxElementStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxElementStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxEmptyExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxEmptyExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxEmptyStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxEmptyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxExpressionContainer">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxExpressionContainer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxExpressionContainerStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxExpressionContainerStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxIdentifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxIdentifierStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxIdentifierStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxMemberExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxMemberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxMemberStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxMemberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxNamespacedName">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxNamespacedName
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxOpeningElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxOpeningElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxSpreadAttribute">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadAttribute
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxSpreadChild">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadChild
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxSpreadChildStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadChildStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxText">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxText
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.jsxTextStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxTextStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.labeledStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>labeledStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.letExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>letExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.letStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>letStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.line">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>line
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.literal">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>literal
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.literalStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>literalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.logicalExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>logicalExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.logicalStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>logicalStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.memberExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>memberExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.memberStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>memberStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.memberTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>memberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.metaProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>metaProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.metaPropertyStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>metaPropertyStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.methodDefinition">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>methodDefinition
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.mixedTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>mixedTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.newExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>newExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.newStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>newStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.noop">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>noop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.nullLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.nullLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.nullLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.nullTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>nullTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.nullableTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>nullableTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.numberLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>numberLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.numberTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>numberTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.numericLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.numericLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.numericLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectMethod">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectMethod
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectTypeCallProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeCallProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectTypeIndexer">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeIndexer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.objectTypeProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.parenthesizedExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>parenthesizedExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.parenthesizedStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>parenthesizedStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.position">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>position
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.program">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>program
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.property">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>property
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.propertyPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>propertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.qualifiedTypeIdentifier">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>qualifiedTypeIdentifier
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.regExpLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>regExpLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.regExpLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>regExpLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.restElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>restElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.restProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>restProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.returnStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>returnStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.sequenceExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>sequenceExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.sequenceStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>sequenceStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.sourceLocation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>sourceLocation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.spreadElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.spreadElementPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadElementPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.spreadProperty">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadProperty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.spreadPropertyPattern">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadPropertyPattern
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.stringLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.stringLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.stringLiteralTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteralTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.stringTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>stringTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.super">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>super
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.superStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>superStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.switchCase">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>switchCase
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.switchStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>switchStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.taggedTemplateExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>taggedTemplateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.taggedTemplateStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>taggedTemplateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.templateElement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>templateElement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.templateLiteral">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>templateLiteral
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.templateLiteralStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>templateLiteralStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.thisExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>thisExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.thisStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>thisStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.thisTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>thisTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.throwStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>throwStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.tryStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>tryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.tupleTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>tupleTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeAlias">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeAlias
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeCastExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeCastExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeCastStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeCastStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeParameter">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeParameterDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameterDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeParameterInstantiation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameterInstantiation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.typeofTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>typeofTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.unaryExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>unaryExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.unaryStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>unaryStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.unionTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>unionTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.updateExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>updateExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.updateStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>updateStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.variableDeclaration">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>variableDeclaration
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.variableDeclarator">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>variableDeclarator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.voidTypeAnnotation">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>voidTypeAnnotation
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.whileStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>whileStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.withStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>withStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.yieldExpression">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>yieldExpression
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ast-types.builders.yieldStatement">
            function <span class="apidocSignatureSpan">ast-types.builders.</span>yieldStatement
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types" id="apidoc.module.ast-types">module ast-types</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.NodePath" id="apidoc.element.ast-types.NodePath">
        function <span class="apidocSignatureSpan">ast-types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error(&#x22;NodePath constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path" id="apidoc.element.ast-types.Path">
        function <span class="apidocSignatureSpan">ast-types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error(&#x22;Path constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error(&#x22;&#x22;);
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path&#x27;s value was reached.
    this.name = name;

    // Calling path.get(&#x22;child&#x22;) multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor" id="apidoc.element.ast-types.PathVisitor">
        function <span class="apidocSignatureSpan">ast-types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          &#x22;PathVisitor constructor cannot be invoked without &#x27;new&#x27;&#x22;
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, &#x22;Block&#x22;) ||
      hasOwn.call(this._methodNameTable, &#x22;Line&#x22;);

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type" id="apidoc.element.ast-types.Type">
        function <span class="apidocSignatureSpan">ast-types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error(&#x22;Type constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }

    // Unfortunately we can&#x27;t elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + &#x22; is not a function&#x22;);
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + &#x22; is neither a function nor a string&#x22;);
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &#x26;&#x26; deep &#x26;&#x26; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.astNodesAreEquivalent" id="apidoc.element.ast-types.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">ast-types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.defineMethod" id="apidoc.element.ast-types.defineMethod">
        function <span class="apidocSignatureSpan">ast-types.</span>defineMethod
        <span class="apidocSignatureSpan">(name, func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defineMethod = function (name, func) {
    var old = nodePrototype[name];

    // Pass undefined as func to delete nodePrototype[name].
    if (isUndefined.check(func)) {
        delete nodePrototype[name];

    } else {
        isFunction.assert(func);

        Object.defineProperty(nodePrototype, name, {
            enumerable: true, // For discoverability.
            configurable: true, // For delete proto[name].
            value: func
        });
    }

    return old;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.eachField" id="apidoc.element.ast-types.eachField">
        function <span class="apidocSignatureSpan">ast-types.</span>eachField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachField = function (object, callback, context) {
    getFieldNames(object).forEach(function (name) {
        callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }, context);
};
```

So here&#x27;s how you might make a copy of an AST node:
```js
var copy = {};
require(&#x22;ast-types&#x22;).<span class="apidocCodeKeywordSpan">eachField</span>(node, function(name, value) {
    // Note that undefined fields will be visited too, according to
    // the rules associated with node.type, and default field values
    // will be substituted if appropriate.
    copy[name] = value;
})
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.finalize" id="apidoc.element.ast-types.finalize">
        function <span class="apidocSignatureSpan">ast-types.</span>finalize
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">finalize = function () {
    Object.keys(defCache).forEach(function (name) {
        defCache[name].finalize();
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
.bases(&#x22;Node&#x22;)
.build(&#x22;name&#x22;, &#x22;program&#x22;)
.field(&#x22;name&#x22;, string)
.field(&#x22;program&#x22;, def(&#x22;Program&#x22;));

// Prevent further modifications to the File type (and any other
// types newly introduced by def(...)).
types.<span class="apidocCodeKeywordSpan">finalize</span>();

// The b.file builder function is now available. It expects two
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.file(&#x22;main.js&#x22;, b.program([
// Pointless program contents included for extra color.
b.functionDeclaration(b.identifier(&#x22;succ&#x22;), [
    b.identifier(&#x22;x&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.getFieldNames" id="apidoc.element.ast-types.getFieldNames">
        function <span class="apidocSignatureSpan">ast-types.</span>getFieldNames
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldNames(object) {
    var d = Def.fromValue(object);
    if (d) {
        return d.fieldNames.slice(0);
    }

    if (&#x22;type&#x22; in object) {
        throw new Error(
          &#x22;did not recognize object of type &#x22; +
          JSON.stringify(object.type)
        );
    }

    return Object.keys(object);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
`getFieldValue`:
```js
var types = require(&#x22;ast-types&#x22;);
var partialFunExpr = { type: &#x22;FunctionExpression&#x22; };

// Even though partialFunExpr doesn&#x27;t actually contain all the fields that
// are expected for a FunctionExpression, types.getFieldNames knows:
console.log(types.<span class="apidocCodeKeywordSpan">getFieldNames</span>(partialFunExpr));
// [ &#x27;type&#x27;, &#x27;id&#x27;, &#x27;params&#x27;, &#x27;body&#x27;, &#x27;generator&#x27;, &#x27;expression&#x27;,
//   &#x27;defaults&#x27;, &#x27;rest&#x27;, &#x27;async&#x27; ]

// For fields that have default values, types.getFieldValue will return
// the default if the field is not actually defined.
console.log(types.getFieldValue(partialFunExpr, &#x22;generator&#x22;));
// false
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.getFieldValue" id="apidoc.element.ast-types.getFieldValue">
        function <span class="apidocSignatureSpan">ast-types.</span>getFieldValue
        <span class="apidocSignatureSpan">(object, fieldName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFieldValue(object, fieldName) {
    var d = Def.fromValue(object);
    if (d) {
        var field = d.allFields[fieldName];
        if (field) {
            return field.getValue(object);
        }
    }

    return object &#x26;&#x26; object[fieldName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// are expected for a FunctionExpression, types.getFieldNames knows:
console.log(types.getFieldNames(partialFunExpr));
// [ &#x27;type&#x27;, &#x27;id&#x27;, &#x27;params&#x27;, &#x27;body&#x27;, &#x27;generator&#x27;, &#x27;expression&#x27;,
//   &#x27;defaults&#x27;, &#x27;rest&#x27;, &#x27;async&#x27; ]

// For fields that have default values, types.getFieldValue will return
// the default if the field is not actually defined.
console.log(types.<span class="apidocCodeKeywordSpan">getFieldValue</span>(partialFunExpr, &#x22;generator&#x22;));
// false
```

Two more low-level helper functions, `eachField` and `someField`, are
defined in terms of `getFieldNames` and `getFieldValue`:
```js
// Iterate over all defined fields of an object, including those missing
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.getSupertypeNames" id="apidoc.element.ast-types.getSupertypeNames">
        function <span class="apidocSignatureSpan">ast-types.</span>getSupertypeNames
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSupertypeNames = function (typeName) {
    if (!hasOwn.call(defCache, typeName)) {
        throw new Error(&#x22;&#x22;);
    }
    var d = defCache[typeName];
    if (d.finalized !== true) {
        throw new Error(&#x22;&#x22;);
    }
    return d.supertypeList.slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.someField" id="apidoc.element.ast-types.someField">
        function <span class="apidocSignatureSpan">ast-types.</span>someField
        <span class="apidocSignatureSpan">(object, callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">someField = function (object, callback, context) {
    return getFieldNames(object).some(function (name) {
        return callback.call(this, name, getFieldValue(object, name));
    }, context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    if (isArray.check(node)) {
        return node.some(containsCallExpression);
    }

    if (n.Node.check(node)) {
        return types.<span class="apidocCodeKeywordSpan">someField</span>(node, function (name, child) {
            return containsCallExpression(child);
        });
    }

    return false;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.use" id="apidoc.element.ast-types.use">
        function <span class="apidocSignatureSpan">ast-types.</span>use
        <span class="apidocSignatureSpan">(plugin)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function use(plugin) {
    var idx = used.indexOf(plugin);
    if (idx === -1) {
        idx = used.length;
        used.push(plugin);
        usedResult[idx] = plugin(fork);
    }
    return usedResult[idx];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...






module.exports = function (fork) {
fork.<span class="apidocCodeKeywordSpan">use</span>(require(&#x22;./es7&#x22;));

var types = fork.use(require(&#x22;../lib/types&#x22;));
var defaults = fork.use(require(&#x22;../lib/shared&#x22;)).defaults;
var def = types.Type.def;
var or = types.Type.or;

def(&#x22;Noop&#x22;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.visit" id="apidoc.element.ast-types.visit">
        function <span class="apidocSignatureSpan">ast-types.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here&#x27;s a trivial example of how you might assert that `arguments.callee`
is never used in `ast`:
```js
var assert = require(&#x22;assert&#x22;);
var types = require(&#x22;ast-types&#x22;);
var n = types.namedTypes;

types.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
    // This method will be called for any node with .type &#x22;MemberExpression&#x22;:
    visitMemberExpression: function(path) {
// Visitor methods receive a single argument, a NodePath object
// wrapping the node of interest.
var node = path.node;

if (n.Identifier.check(node.object) &#x26;&#x26;
...</pre></li>
    </ul>
















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.NodePath" id="apidoc.module.ast-types.NodePath">module ast-types.NodePath</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.NodePath.NodePath" id="apidoc.element.ast-types.NodePath.NodePath">
        function <span class="apidocSignatureSpan">ast-types.</span>NodePath
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NodePath(value, parentPath, name) {
    if (!(this instanceof NodePath)) {
        throw new Error(&#x22;NodePath constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }
    Path.call(this, value, parentPath, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.NodePath.prototype" id="apidoc.module.ast-types.NodePath.prototype">module ast-types.NodePath.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype._computeNode" id="apidoc.element.ast-types.NodePath.prototype._computeNode">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeNode
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeNode = function () {
    var value = this.value;
    if (n.Node.check(value)) {
        return value;
    }

    var pp = this.parentPath;
    return pp &#x26;&#x26; pp.node || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    });

    Object.defineProperties(NPp, {
node: {
    get: function () {
        Object.defineProperty(this, &#x22;node&#x22;, {
            configurable: true, // Enable deletion.
            value: this.<span class="apidocCodeKeywordSpan">_computeNode</span>()
        });

        return this.node;
    }
},

parent: {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype._computeParent" id="apidoc.element.ast-types.NodePath.prototype._computeParent">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeParent
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeParent = function () {
    var value = this.value;
    var pp = this.parentPath;

    if (!n.Node.check(value)) {
        while (pp &#x26;&#x26; !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        if (pp) {
            pp = pp.parentPath;
        }
    }

    while (pp &#x26;&#x26; !n.Node.check(pp.value)) {
        pp = pp.parentPath;
    }

    return pp || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
},

parent: {
    get: function () {
        Object.defineProperty(this, &#x22;parent&#x22;, {
            configurable: true, // Enable deletion.
            value: this.<span class="apidocCodeKeywordSpan">_computeParent</span>()
        });

        return this.parent;
    }
},

scope: {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype._computeScope" id="apidoc.element.ast-types.NodePath.prototype._computeScope">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>_computeScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_computeScope = function () {
    var value = this.value;
    var pp = this.parentPath;
    var scope = pp &#x26;&#x26; pp.scope;

    if (n.Node.check(value) &#x26;&#x26;
      Scope.isEstablishedBy(value)) {
        scope = new Scope(this, scope);
    }

    return scope || null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    },

    scope: {
        get: function () {
            Object.defineProperty(this, &#x22;scope&#x22;, {
                configurable: true, // Enable deletion.
                value: this.<span class="apidocCodeKeywordSpan">_computeScope</span>()
            });

            return this.scope;
        }
    }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.canBeFirstInStatement" id="apidoc.element.ast-types.NodePath.prototype.canBeFirstInStatement">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>canBeFirstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">canBeFirstInStatement = function () {
    var node = this.node;
    return !n.FunctionExpression.check(node)
      &#x26;&#x26; !n.ObjectExpression.check(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              this.name === &#x22;callee&#x22; &#x26;&#x26;
              parent.callee === node) {
                return containsCallExpression(node);
            }
    }

    if (assumeExpressionContext !== true &#x26;&#x26;
      !this.<span class="apidocCodeKeywordSpan">canBeFirstInStatement</span>() &#x26;&#x26;
      this.firstInStatement())
        return true;

    return false;
};

function isBinary(node) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.firstInStatement" id="apidoc.element.ast-types.NodePath.prototype.firstInStatement">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>firstInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstInStatement = function () {
    return firstInStatement(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
              parent.callee === node) {
                return containsCallExpression(node);
            }
    }

    if (assumeExpressionContext !== true &#x26;&#x26;
      !this.canBeFirstInStatement() &#x26;&#x26;
      this.<span class="apidocCodeKeywordSpan">firstInStatement</span>())
        return true;

    return false;
};

function isBinary(node) {
    return n.BinaryExpression.check(node)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.getValueProperty" id="apidoc.element.ast-types.NodePath.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValueProperty = function (name) {
    return types.getFieldValue(this.value, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Lazily create the child cache. This also cheapens cache
    // invalidation, since you can just reset path.__childCache to null.
    return path.__childCache || (path.__childCache = Object.create(null));
}

function getChildPath(path, name) {
    var cache = getChildCache(path);
    var actualChildValue = path.<span class="apidocCodeKeywordSpan">getValueProperty</span>(name);
    var childPath = cache[name];
    if (!hasOwn.call(cache, name) ||
      // Ensure consistency between cache and reality.
      childPath.value !== actualChildValue) {
        childPath = cache[name] = new path.constructor(
          actualChildValue, path, name
        );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.needsParens" id="apidoc.element.ast-types.NodePath.prototype.needsParens">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>needsParens
        <span class="apidocSignatureSpan">(assumeExpressionContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">needsParens = function (assumeExpressionContext) {
    var pp = this.parentPath;
    if (!pp) {
        return false;
    }

    var node = this.value;

    // Only expressions need parentheses.
    if (!n.Expression.check(node)) {
        return false;
    }

    // Identifiers never need parentheses.
    if (node.type === &#x22;Identifier&#x22;) {
        return false;
    }

    while (!n.Node.check(pp.value)) {
        pp = pp.parentPath;
        if (!pp) {
            return false;
        }
    }

    var parent = pp.value;

    switch (node.type) {
        case &#x22;UnaryExpression&#x22;:
        case &#x22;SpreadElement&#x22;:
        case &#x22;SpreadProperty&#x22;:
            return parent.type === &#x22;MemberExpression&#x22;
              &#x26;&#x26; this.name === &#x22;object&#x22;
              &#x26;&#x26; parent.object === node;

        case &#x22;BinaryExpression&#x22;:
        case &#x22;LogicalExpression&#x22;:
            switch (parent.type) {
                case &#x22;CallExpression&#x22;:
                    return this.name === &#x22;callee&#x22;
                      &#x26;&#x26; parent.callee === node;

                case &#x22;UnaryExpression&#x22;:
                case &#x22;SpreadElement&#x22;:
                case &#x22;SpreadProperty&#x22;:
                    return true;

                case &#x22;MemberExpression&#x22;:
                    return this.name === &#x22;object&#x22;
                      &#x26;&#x26; parent.object === node;

                case &#x22;BinaryExpression&#x22;:
                case &#x22;LogicalExpression&#x22;:
                    var po = parent.operator;
                    var pp = PRECEDENCE[po];
                    var no = node.operator;
                    var np = PRECEDENCE[no];

                    if (pp &#x3e; np) {
                        return true;
                    }

                    if (pp === np &#x26;&#x26; this.name === &#x22;right&#x22;) {
                        if (parent.right !== node) {
                            throw new Error(&#x22;Nodes must be equal&#x22;);
                        }
                        return true;
                    }

                default:
                    return false;
            }

        case &#x22;SequenceExpression&#x22;:
            switch (parent.type) {
                case &#x22;ForStatement&#x22;:
                    // Although parentheses wouldn&#x27;t hurt around sequence
                    // expressions in the head of for loops, traditional style
                    // dictates that e.g. i++, j++ should not be wrapped with
                    // parentheses.
                    return false;

                case &#x22;ExpressionStatement&#x22;:
                    return this.name !== &#x22;expression&#x22;;

                default:
                    // Otherwise err on the side of overparenthesization, adding
                    // explicit exceptions above if this proves overzealous.
                    return true;
            }

        case &#x22;YieldExpression&#x22;:
            switch (parent.type) {
                case &#x22;BinaryExpression&#x22;:
                case &#x22;LogicalExpression&#x22;:
                case &#x22;UnaryExpression&#x22;:
                case &#x22;SpreadElement&#x22;:
                case &#x22;SpreadProperty&#x22;:
                case &#x22;CallExpression&#x22;:
                case &#x22;MemberExpression&#x22;:
                case &#x22;NewExpression&#x22;:
                case &#x22;ConditionalExpression&#x22;:
                case &#x22;YieldExpression&#x22;:
                    return true;

                default:
                    return false;
            }

        case &#x22;Literal&#x22;:
            return parent.type === &#x22;MemberExpression&#x22;
              &#x26;&#x26; isNumber.check(node.value)
              &#x26;&#x26; this.name === &#x22;object&#x22;
              &#x26;&#x26; parent.object === node;

        case &#x22;AssignmentExpression&#x22;:
        case &#x22;ConditionalExpression&#x22;:
            switch (parent.type) {
                case &#x22;UnaryExpression&#x22;:
                case &#x22;SpreadElement&#x22;:
                case &#x22;SpreadProperty&#x22;:
                case &#x22;BinaryExpression&#x22;:
                case &#x22;LogicalExpression&#x22;:
                    return true;

                case &#x22;CallExpression&#x22;:
                    return this.name === &#x22;callee&#x22;
                      &#x26;&#x26; parent.callee === node;

                case &#x22;ConditionalExpression&#x22;:
                    return this.name === &#x22; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.prune" id="apidoc.element.ast-types.NodePath.prototype.prune">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>prune
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prune = function () {
    var remainingNodePath = this.parent;

    this.replace();

    return cleanUpNodesAfterPrune(remainingNodePath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
path.get(&#x22;elements&#x22;, 2).replace(
    b.identifier(&#x22;foo&#x22;),
    b.thisExpression()
);

// Remove a node and its parent if it would leave a redundant AST node:
//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.
path.<span class="apidocCodeKeywordSpan">prune</span>(); //returns the closest parent `NodePath`.

// Remove a node from a list of nodes:
path.get(&#x22;elements&#x22;, 3).replace();

// Add three new nodes to the beginning of a list of nodes:
path.get(&#x22;elements&#x22;).unshift(a, b, c);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.NodePath.prototype.replace" id="apidoc.element.ast-types.NodePath.prototype.replace">
        function <span class="apidocSignatureSpan">ast-types.NodePath.prototype.</span>replace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function () {
    delete this.node;
    delete this.parent;
    delete this.scope;
    return Path.prototype.replace.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // Similar to doing node.body.body.unshift(restVarDecl), except
        // that the other NodePath objects wrapping body statements will
        // have their indexes updated to accommodate the new statement.
        path.get(&#x22;body&#x22;, &#x22;body&#x22;).unshift(restVarDecl);

        // Nullify node.rest now that we have simulated the behavior of
        // the rest parameter using ordinary JavaScript.
        path.get(&#x22;rest&#x22;).<span class="apidocCodeKeywordSpan">replace</span>(null);

        // There&#x27;s nothing wrong with doing node.rest = null, but I wanted
        // to point out that the above statement has the same effect.
        assert.strictEqual(node.rest, null);
    }
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.Path" id="apidoc.module.ast-types.Path">module ast-types.Path</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.Path.Path" id="apidoc.element.ast-types.Path.Path">
        function <span class="apidocSignatureSpan">ast-types.</span>Path
        <span class="apidocSignatureSpan">(value, parentPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Path(value, parentPath, name) {
    if (!(this instanceof Path)) {
        throw new Error(&#x22;Path constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }

    if (parentPath) {
        if (!(parentPath instanceof Path)) {
            throw new Error(&#x22;&#x22;);
        }
    } else {
        parentPath = null;
        name = null;
    }

    // The value encapsulated by this Path, generally equal to
    // parentPath.value[name] if we have a parentPath.
    this.value = value;

    // The immediate parent Path of this Path.
    this.parentPath = parentPath;

    // The name of the property of parentPath.value through which this
    // Path&#x27;s value was reached.
    this.name = name;

    // Calling path.get(&#x22;child&#x22;) multiple times always returns the same
    // child Path object, for both performance and consistency reasons.
    this.__childCache = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.Path.prototype" id="apidoc.module.ast-types.Path.prototype">module ast-types.Path.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.each" id="apidoc.element.ast-types.Path.prototype.each">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>each
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function each(callback, context) {
    var childPaths = [];
    var len = this.value.length;
    var i = 0;

    // Collect all the original child paths before invoking the callback.
    for (var i = 0; i &#x3c; len; ++i) {
        if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
        }
    }

    // Invoke the callback on just the original child paths, regardless of
    // any modifications made to the array by the callback. I chose these
    // semantics over cleverly invoking the callback on new elements because
    // this way is much easier to reason about.
    context = context || this;
    for (i = 0; i &#x3c; len; ++i) {
        if (hasOwn.call(childPaths, i)) {
            callback.call(context, childPaths[i]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!(visitor instanceof PathVisitor)) {
throw new Error(&#x22;&#x22;);
        }

        var value = path.value;

        if (isArray.check(value)) {
path.<span class="apidocCodeKeywordSpan">each</span>(visitor.visitWithoutReset, visitor);
        } else if (!isObject.check(value)) {
// No children to visit.
        } else {
var childNames = types.getFieldNames(value);

// The .comments field of the Node type is hidden, so we only
// visit it if the visitor defines visitBlock or visitLine, and
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.filter" id="apidoc.element.ast-types.Path.prototype.filter">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>filter
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function filter(callback, context) {
    var result = [];

    this.each(function (childPath) {
        if (callback.call(this, childPath)) {
            result.push(childPath);
        }
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.get" id="apidoc.element.ast-types.Path.prototype.get">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>get
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function get(name) {
    var path = this;
    var names = arguments;
    var count = names.length;

    for (var i = 0; i &#x3c; count; ++i) {
        path = getChildPath(path, names[i]);
    }

    return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        ])
    )
]);

// Similar to doing node.body.body.unshift(restVarDecl), except
// that the other NodePath objects wrapping body statements will
// have their indexes updated to accommodate the new statement.
path.<span class="apidocCodeKeywordSpan">get</span>(&#x22;body&#x22;, &#x22;body&#x22;).unshift(restVarDecl);

// Nullify node.rest now that we have simulated the behavior of
// the rest parameter using ordinary JavaScript.
path.get(&#x22;rest&#x22;).replace(null);

// There&#x27;s nothing wrong with doing node.rest = null, but I wanted
// to point out that the above statement has the same effect.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.getValueProperty" id="apidoc.element.ast-types.Path.prototype.getValueProperty">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>getValueProperty
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getValueProperty(name) {
    return this.value[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Lazily create the child cache. This also cheapens cache
    // invalidation, since you can just reset path.__childCache to null.
    return path.__childCache || (path.__childCache = Object.create(null));
}

function getChildPath(path, name) {
    var cache = getChildCache(path);
    var actualChildValue = path.<span class="apidocCodeKeywordSpan">getValueProperty</span>(name);
    var childPath = cache[name];
    if (!hasOwn.call(cache, name) ||
      // Ensure consistency between cache and reality.
      childPath.value !== actualChildValue) {
        childPath = cache[name] = new path.constructor(
          actualChildValue, path, name
        );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.insertAfter" id="apidoc.element.ast-types.Path.prototype.insertAfter">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertAfter
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAfter(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name + 1];
    for (var i = 0; i &#x3c; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Remove and return the last node in a list of nodes:
path.get(&#x22;elements&#x22;).pop();

// Insert a new node before/after the seventh node in a list of nodes:
var seventh = path.get(&#x22;elements&#x22;, 6);
seventh.insertBefore(newNode);
seventh.<span class="apidocCodeKeywordSpan">insertAfter</span>(newNode);

// Insert a new element at index 5 in a list of nodes:
path.get(&#x22;elements&#x22;).insertAt(5, newNode);
```

Scope
---
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.insertAt" id="apidoc.element.ast-types.Path.prototype.insertAt">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertAt
        <span class="apidocSignatureSpan">(index, node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertAt(index, node) {
    var argc = arguments.length;
    var move = getMoves(this, argc - 1, index);
    if (move === emptyMoves) {
        return this;
    }

    index = Math.max(index, 0);

    for (var i = 1; i &#x3c; argc; ++i) {
        this.value[index + i - 1] = arguments[i];
    }

    move();

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Insert a new node before/after the seventh node in a list of nodes:
var seventh = path.get(&#x22;elements&#x22;, 6);
seventh.insertBefore(newNode);
seventh.insertAfter(newNode);

// Insert a new element at index 5 in a list of nodes:
path.get(&#x22;elements&#x22;).<span class="apidocCodeKeywordSpan">insertAt</span>(5, newNode);
```

Scope
---

The object exposed as `path.scope` during AST traversals provides
information about variable and function declarations in the scope that
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.insertBefore" id="apidoc.element.ast-types.Path.prototype.insertBefore">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>insertBefore
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function insertBefore(node) {
    var pp = this.parentPath;
    var argc = arguments.length;
    var insertAtArgs = [this.name];
    for (var i = 0; i &#x3c; argc; ++i) {
        insertAtArgs.push(arguments[i]);
    }
    return pp.insertAt.apply(pp, insertAtArgs);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
path.get(&#x22;elements&#x22;).push(d, e);

// Remove and return the last node in a list of nodes:
path.get(&#x22;elements&#x22;).pop();

// Insert a new node before/after the seventh node in a list of nodes:
var seventh = path.get(&#x22;elements&#x22;, 6);
seventh.<span class="apidocCodeKeywordSpan">insertBefore</span>(newNode);
seventh.insertAfter(newNode);

// Insert a new element at index 5 in a list of nodes:
path.get(&#x22;elements&#x22;).insertAt(5, newNode);
```

Scope
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.map" id="apidoc.element.ast-types.Path.prototype.map">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>map
        <span class="apidocSignatureSpan">(callback, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map(callback, context) {
    var result = [];

    this.each(function (childPath) {
        result.push(callback.call(this, childPath));
    }, context);

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (problemPath.length === 0) {
            if (a !== b) {
                throw new Error(&#x22;Nodes must be equal&#x22;);
            }
        } else {
            throw new Error(
              &#x22;Nodes differ in the following path: &#x22; +
              problemPath.<span class="apidocCodeKeywordSpan">map</span>(subscriptForProperty).join(&#x22;&#x22;)
            );
        }
    }
};

function subscriptForProperty(property) {
    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.pop" id="apidoc.element.ast-types.Path.prototype.pop">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pop() {
    isArray.assert(this.value);
    var cache = getChildCache(this);
    delete cache[this.value.length - 1];
    delete cache.length;
    return this.value.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Remove and return the first node in a list of nodes:
path.get(&#x22;elements&#x22;).shift();

// Push two new nodes onto the end of a list of nodes:
path.get(&#x22;elements&#x22;).push(d, e);

// Remove and return the last node in a list of nodes:
path.get(&#x22;elements&#x22;).<span class="apidocCodeKeywordSpan">pop</span>();

// Insert a new node before/after the seventh node in a list of nodes:
var seventh = path.get(&#x22;elements&#x22;, 6);
seventh.insertBefore(newNode);
seventh.insertAfter(newNode);

// Insert a new element at index 5 in a list of nodes:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.push" id="apidoc.element.ast-types.Path.prototype.push">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>push
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function push(node) {
    isArray.assert(this.value);
    delete getChildCache(this).length
    return this.value.push.apply(this.value, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Add three new nodes to the beginning of a list of nodes:
path.get(&#x22;elements&#x22;).unshift(a, b, c);

// Remove and return the first node in a list of nodes:
path.get(&#x22;elements&#x22;).shift();

// Push two new nodes onto the end of a list of nodes:
path.get(&#x22;elements&#x22;).<span class="apidocCodeKeywordSpan">push</span>(d, e);

// Remove and return the last node in a list of nodes:
path.get(&#x22;elements&#x22;).pop();

// Insert a new node before/after the seventh node in a list of nodes:
var seventh = path.get(&#x22;elements&#x22;, 6);
seventh.insertBefore(newNode);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.replace" id="apidoc.element.ast-types.Path.prototype.replace">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>replace
        <span class="apidocSignatureSpan">(replacement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replace(replacement) {
    var results = [];
    var parentValue = this.parentPath.value;
    var parentCache = getChildCache(this.parentPath);
    var count = arguments.length;

    repairRelationshipWithParent(this);

    if (isArray.check(parentValue)) {
        var originalLength = parentValue.length;
        var move = getMoves(this.parentPath, count - 1, this.name + 1);

        var spliceArgs = [this.name, 1];
        for (var i = 0; i &#x3c; count; ++i) {
            spliceArgs.push(arguments[i]);
        }

        var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

        if (splicedOut[0] !== this.value) {
            throw new Error(&#x22;&#x22;);
        }
        if (parentValue.length !== (originalLength - 1 + count)) {
            throw new Error(&#x22;&#x22;);
        }

        move();

        if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;

        } else {
            if (parentValue[this.name] !== replacement) {
                throw new Error(&#x22;&#x22;);
            }

            if (this.value !== replacement) {
                this.value = replacement;
                this.__childCache = null;
            }

            for (i = 0; i &#x3c; count; ++i) {
                results.push(this.parentPath.get(this.name + i));
            }

            if (results[0] !== this) {
                throw new Error(&#x22;&#x22;);
            }
        }

    } else if (count === 1) {
        if (this.value !== replacement) {
            this.__childCache = null;
        }
        this.value = parentValue[this.name] = replacement;
        results.push(this);

    } else if (count === 0) {
        delete parentValue[this.name];
        delete this.value;
        this.__childCache = null;

        // Leave this path cached as parentCache[this.name], even though
        // it no longer has a value defined.

    } else {
        throw new Error(&#x22;Could not replace path&#x22;);
    }

    return results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        // Similar to doing node.body.body.unshift(restVarDecl), except
        // that the other NodePath objects wrapping body statements will
        // have their indexes updated to accommodate the new statement.
        path.get(&#x22;body&#x22;, &#x22;body&#x22;).unshift(restVarDecl);

        // Nullify node.rest now that we have simulated the behavior of
        // the rest parameter using ordinary JavaScript.
        path.get(&#x22;rest&#x22;).<span class="apidocCodeKeywordSpan">replace</span>(null);

        // There&#x27;s nothing wrong with doing node.rest = null, but I wanted
        // to point out that the above statement has the same effect.
        assert.strictEqual(node.rest, null);
    }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.shift" id="apidoc.element.ast-types.Path.prototype.shift">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>shift
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shift() {
    var move = getMoves(this, -1);
    var result = this.value.shift();
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Remove a node from a list of nodes:
path.get(&#x22;elements&#x22;, 3).replace();

// Add three new nodes to the beginning of a list of nodes:
path.get(&#x22;elements&#x22;).unshift(a, b, c);

// Remove and return the first node in a list of nodes:
path.get(&#x22;elements&#x22;).<span class="apidocCodeKeywordSpan">shift</span>();

// Push two new nodes onto the end of a list of nodes:
path.get(&#x22;elements&#x22;).push(d, e);

// Remove and return the last node in a list of nodes:
path.get(&#x22;elements&#x22;).pop();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Path.prototype.unshift" id="apidoc.element.ast-types.Path.prototype.unshift">
        function <span class="apidocSignatureSpan">ast-types.Path.prototype.</span>unshift
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unshift(node) {
    var move = getMoves(this, arguments.length);
    var result = this.value.unshift.apply(this.value, arguments);
    move();
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        b.callExpression(sliceExpr, [
            b.identifier(&#x22;arguments&#x22;),
            b.literal(node.params.length)
        ])
    )
]);

// Similar to doing node.body.body.<span class="apidocCodeKeywordSpan">unshift</span>(restVarDecl), except
// that the other NodePath objects wrapping body statements will
// have their indexes updated to accommodate the new statement.
path.get(&#x22;body&#x22;, &#x22;body&#x22;).unshift(restVarDecl);

// Nullify node.rest now that we have simulated the behavior of
// the rest parameter using ordinary JavaScript.
path.get(&#x22;rest&#x22;).replace(null);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.PathVisitor" id="apidoc.module.ast-types.PathVisitor">module ast-types.PathVisitor</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.PathVisitor" id="apidoc.element.ast-types.PathVisitor.PathVisitor">
        function <span class="apidocSignatureSpan">ast-types.</span>PathVisitor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PathVisitor() {
    if (!(this instanceof PathVisitor)) {
        throw new Error(
          &#x22;PathVisitor constructor cannot be invoked without &#x27;new&#x27;&#x22;
        );
    }

    // Permanent state.
    this._reusableContextStack = [];

    this._methodNameTable = computeMethodNameTable(this);
    this._shouldVisitComments =
      hasOwn.call(this._methodNameTable, &#x22;Block&#x22;) ||
      hasOwn.call(this._methodNameTable, &#x22;Line&#x22;);

    this.Context = makeContextConstructor(this);

    // State reset every time PathVisitor.prototype.visit is called.
    this._visiting = false;
    this._changeReported = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.fromMethodsObject" id="apidoc.element.ast-types.PathVisitor.fromMethodsObject">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.</span>fromMethodsObject
        <span class="apidocSignatureSpan">(methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromMethodsObject(methods) {
    if (methods instanceof PathVisitor) {
        return methods;
    }

    if (!isObject.check(methods)) {
        // An empty visitor?
        return new PathVisitor;
    }

    function Visitor() {
        if (!(this instanceof Visitor)) {
            throw new Error(
              &#x22;Visitor constructor cannot be invoked without &#x27;new&#x27;&#x22;
            );
        }
        PathVisitor.call(this);
    }

    var Vp = Visitor.prototype = Object.create(PVp);
    Vp.constructor = Visitor;

    extend(Vp, methods);
    extend(Visitor, PathVisitor);

    isFunction.assert(Visitor.fromMethodsObject);
    isFunction.assert(Visitor.visit);

    return new Visitor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        }
    }

    return target;
}

PathVisitor.visit = function visit(node, methods) {
    return PathVisitor.<span class="apidocCodeKeywordSpan">fromMethodsObject</span>(methods).visit(node);
};

var PVp = PathVisitor.prototype;

PVp.visit = function () {
    if (this._visiting) {
        throw new Error(
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.visit" id="apidoc.element.ast-types.PathVisitor.visit">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.</span>visit
        <span class="apidocSignatureSpan">(node, methods)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function visit(node, methods) {
    return PathVisitor.fromMethodsObject(methods).visit(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here&#x27;s a trivial example of how you might assert that `arguments.callee`
is never used in `ast`:
```js
var assert = require(&#x22;assert&#x22;);
var types = require(&#x22;ast-types&#x22;);
var n = types.namedTypes;

types.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
    // This method will be called for any node with .type &#x22;MemberExpression&#x22;:
    visitMemberExpression: function(path) {
// Visitor methods receive a single argument, a NodePath object
// wrapping the node of interest.
var node = path.node;

if (n.Identifier.check(node.object) &#x26;&#x26;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.PathVisitor.prototype" id="apidoc.module.ast-types.PathVisitor.prototype">module ast-types.PathVisitor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.AbortRequest" id="apidoc.element.ast-types.PathVisitor.prototype.AbortRequest">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>AbortRequest
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AbortRequest() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return root;
    };

    PVp.AbortRequest = function AbortRequest() {};
    PVp.abort = function () {
var visitor = this;
visitor._abortRequested = true;
var request = new visitor.<span class="apidocCodeKeywordSpan">AbortRequest</span>();

// If you decide to catch this exception and stop it from propagating,
// make sure to call its cancel method to avoid silencing other
// exceptions that might be thrown later in the traversal.
request.cancel = function () {
    visitor._abortRequested = false;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.abort" id="apidoc.element.ast-types.PathVisitor.prototype.abort">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>abort
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">abort = function () {
    var visitor = this;
    visitor._abortRequested = true;
    var request = new visitor.AbortRequest();

    // If you decide to catch this exception and stop it from propagating,
    // make sure to call its cancel method to avoid silencing other
    // exceptions that might be thrown later in the traversal.
    request.cancel = function () {
        visitor._abortRequested = false;
    };

    throw request;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var result = false;

    types.visit(funcNode, {
visitThisExpression: function(path) {
    result = true;

    // The quickest way to terminate the traversal is to call
    // this.<span class="apidocCodeKeywordSpan">abort</span>(), which throws a special exception (instanceof
    // this.AbortRequest) that will be caught in the top-level
    // types.visit method, so you don&#x27;t have to worry about
    // catching the exception yourself.
    this.abort();
},

visitFunction: function(path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.acquireContext" id="apidoc.element.ast-types.PathVisitor.prototype.acquireContext">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>acquireContext
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">acquireContext = function (path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().reset(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var methodName = value &#x26;&#x26;
  typeof value === &#x22;object&#x22; &#x26;&#x26;
  typeof value.type === &#x22;string&#x22; &#x26;&#x26;
  this._methodNameTable[value.type];

if (methodName) {
    var context = this.<span class="apidocCodeKeywordSpan">acquireContext</span>(path);
    try {
        return context.invokeVisitorMethod(methodName);
    } finally {
        this.releaseContext(context);
    }

} else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.releaseContext" id="apidoc.element.ast-types.PathVisitor.prototype.releaseContext">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>releaseContext
        <span class="apidocSignatureSpan">(context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">releaseContext = function (context) {
    if (!(context instanceof this.Context)) {
        throw new Error(&#x22;&#x22;);
    }
    this._reusableContextStack.push(context);
    context.currentPath = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this._methodNameTable[value.type];

if (methodName) {
    var context = this.acquireContext(path);
    try {
        return context.invokeVisitorMethod(methodName);
    } finally {
        this.<span class="apidocCodeKeywordSpan">releaseContext</span>(context);
    }

} else {
    // If there was no visitor method to call, visit the children of
    // this node generically.
    return visitChildren(path, this);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.reportChanged" id="apidoc.element.ast-types.PathVisitor.prototype.reportChanged">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>reportChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reportChanged = function () {
    this._changeReported = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

      return PathVisitor.fromMethodsObject(
        newVisitor || this.visitor
      ).visitWithoutReset(path);
  };

sharedContextProtoMethods.reportChanged = function reportChanged() {
    this.visitor.<span class="apidocCodeKeywordSpan">reportChanged</span>();
};

sharedContextProtoMethods.abort = function abort() {
    this.needToCallTraverse = false;
    this.visitor.abort();
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.reset" id="apidoc.element.ast-types.PathVisitor.prototype.reset">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>reset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function (path) {
    // Empty stub; may be reassigned or overridden by subclasses.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return path.value;
}

PVp.acquireContext = function (path) {
    if (this._reusableContextStack.length === 0) {
        return new this.Context(path);
    }
    return this._reusableContextStack.pop().<span class="apidocCodeKeywordSpan">reset</span>(path);
};

PVp.releaseContext = function (context) {
    if (!(context instanceof this.Context)) {
        throw new Error(&#x22;&#x22;);
    }
    this._reusableContextStack.push(context);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.visit" id="apidoc.element.ast-types.PathVisitor.prototype.visit">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>visit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visit = function () {
    if (this._visiting) {
        throw new Error(
          &#x22;Recursively calling visitor.visit(path) resets visitor state. &#x22; +
          &#x22;Try this.visit(path) or this.traverse(path) instead.&#x22;
        );
    }

    // Private state that needs to be reset before every traversal.
    this._visiting = true;
    this._changeReported = false;
    this._abortRequested = false;

    var argc = arguments.length;
    var args = new Array(argc)
    for (var i = 0; i &#x3c; argc; ++i) {
        args[i] = arguments[i];
    }

    if (!(args[0] instanceof NodePath)) {
        args[0] = new NodePath({root: args[0]}).get(&#x22;root&#x22;);
    }

    // Called with the same arguments as .visit.
    this.reset.apply(this, args);

    try {
        var root = this.visitWithoutReset(args[0]);
        var didNotThrow = true;
    } finally {
        this._visiting = false;

        if (!didNotThrow &#x26;&#x26; this._abortRequested) {
            // If this.visitWithoutReset threw an exception and
            // this._abortRequested was set to true, return the root of
            // the AST instead of letting the exception propagate, so that
            // client code does not have to provide a try-catch block to
            // intercept the AbortRequest exception.  Other kinds of
            // exceptions will propagate without being intercepted and
            // rethrown by a catch block, so their stacks will accurately
            // reflect the original throwing context.
            return args[0].value;
        }
    }

    return root;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here&#x27;s a trivial example of how you might assert that `arguments.callee`
is never used in `ast`:
```js
var assert = require(&#x22;assert&#x22;);
var types = require(&#x22;ast-types&#x22;);
var n = types.namedTypes;

types.<span class="apidocCodeKeywordSpan">visit</span>(ast, {
    // This method will be called for any node with .type &#x22;MemberExpression&#x22;:
    visitMemberExpression: function(path) {
// Visitor methods receive a single argument, a NodePath object
// wrapping the node of interest.
var node = path.node;

if (n.Identifier.check(node.object) &#x26;&#x26;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.visitWithoutReset" id="apidoc.element.ast-types.PathVisitor.prototype.visitWithoutReset">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>visitWithoutReset
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">visitWithoutReset = function (path) {
    if (this instanceof this.Context) {
        // Since this.Context.prototype === this, there&#x27;s a chance we
        // might accidentally call context.visitWithoutReset. If that
        // happens, re-invoke the method against context.visitor.
        return this.visitor.visitWithoutReset(path);
    }

    if (!(path instanceof NodePath)) {
        throw new Error(&#x22;&#x22;);
    }

    var value = path.value;

    var methodName = value &#x26;&#x26;
      typeof value === &#x22;object&#x22; &#x26;&#x26;
      typeof value.type === &#x22;string&#x22; &#x26;&#x26;
      this._methodNameTable[value.type];

    if (methodName) {
        var context = this.acquireContext(path);
        try {
            return context.invokeVisitorMethod(methodName);
        } finally {
            this.releaseContext(context);
        }

    } else {
        // If there was no visitor method to call, visit the children of
        // this node generically.
        return visitChildren(path, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
args[0] = new NodePath({root: args[0]}).get(&#x22;root&#x22;);
        }

        // Called with the same arguments as .visit.
        this.reset.apply(this, args);

        try {
var root = this.<span class="apidocCodeKeywordSpan">visitWithoutReset</span>(args[0]);
var didNotThrow = true;
        } finally {
this._visiting = false;

if (!didNotThrow &#x26;&#x26; this._abortRequested) {
    // If this.visitWithoutReset threw an exception and
    // this._abortRequested was set to true, return the root of
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.PathVisitor.prototype.wasChangeReported" id="apidoc.element.ast-types.PathVisitor.prototype.wasChangeReported">
        function <span class="apidocSignatureSpan">ast-types.PathVisitor.prototype.</span>wasChangeReported
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wasChangeReported = function () {
    return this._changeReported;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.Type" id="apidoc.module.ast-types.Type">module ast-types.Type</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.Type.Type" id="apidoc.element.ast-types.Type.Type">
        function <span class="apidocSignatureSpan">ast-types.</span>Type
        <span class="apidocSignatureSpan">(check, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Type(check, name) {
    var self = this;
    if (!(self instanceof Type)) {
        throw new Error(&#x22;Type constructor cannot be invoked without &#x27;new&#x27;&#x22;);
    }

    // Unfortunately we can&#x27;t elegantly reuse isFunction and isString,
    // here, because this code is executed while defining those types.
    if (objToStr.call(check) !== funObjStr) {
        throw new Error(check + &#x22; is not a function&#x22;);
    }

    // The `name` parameter can be either a function or a string.
    var nameObjStr = objToStr.call(name);
    if (!(nameObjStr === funObjStr ||
      nameObjStr === strObjStr)) {
        throw new Error(name + &#x22; is neither a function nor a string&#x22;);
    }

    Object.defineProperties(self, {
        name: {value: name},
        check: {
            value: function (value, deep) {
                var result = check.call(self, value, deep);
                if (!result &#x26;&#x26; deep &#x26;&#x26; objToStr.call(deep) === funObjStr)
                    deep(self, value);
                return result;
            }
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.def" id="apidoc.element.ast-types.Type.def">
        function <span class="apidocSignatureSpan">ast-types.Type.</span>def
        <span class="apidocSignatureSpan">(typeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">def = function (typeName) {
    isString.assert(typeName);
    return hasOwn.call(defCache, typeName)
      ? defCache[typeName]
      : defCache[typeName] = new Def(typeName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.fromArray" id="apidoc.element.ast-types.Type.fromArray">
        function <span class="apidocSignatureSpan">ast-types.Type.</span>fromArray
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromArray = function (arr) {
    if (!isArray.check(arr)) {
        throw new Error(&#x22;&#x22;);
    }
    if (arr.length !== 1) {
        throw new Error(&#x22;only one element type is permitted for typed arrays&#x22;);
    }
    return toType(arr[0]).arrayOf();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The Def type is used as a helper for constructing compound
// interface types for AST nodes.
if (from instanceof Def)
    return from.type;

// Support [ElemType] syntax.
if (isArray.check(from))
    return Type.<span class="apidocCodeKeywordSpan">fromArray</span>(from);

// Support { someField: FieldType, ... } syntax.
if (isObject.check(from))
    return Type.fromObject(from);

if (isFunction.check(from)) {
    var bicfIndex = builtInCtorFns.indexOf(from);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.fromObject" id="apidoc.element.ast-types.Type.fromObject">
        function <span class="apidocSignatureSpan">ast-types.Type.</span>fromObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromObject = function (obj) {
    var fields = Object.keys(obj).map(function (name) {
        return new Field(name, obj[name]);
    });

    return new Type(function (value, deep) {
        return isObject.check(value) &#x26;&#x26; fields.every(function (field) {
              return field.type.check(value[field.name], deep);
          });
    }, function () {
        return &#x22;{ &#x22; + fields.join(&#x22;, &#x22;) + &#x22; }&#x22;;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Support [ElemType] syntax.
if (isArray.check(from))
    return Type.fromArray(from);

// Support { someField: FieldType, ... } syntax.
if (isObject.check(from))
    return Type.<span class="apidocCodeKeywordSpan">fromObject</span>(from);

if (isFunction.check(from)) {
    var bicfIndex = builtInCtorFns.indexOf(from);
    if (bicfIndex &#x3e;= 0) {
        return builtInCtorTypes[bicfIndex];
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.or" id="apidoc.element.ast-types.Type.or">
        function <span class="apidocSignatureSpan">ast-types.Type.</span>or
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">or = function () {
    var types = [];
    var len = arguments.length;
    for (var i = 0; i &#x3c; len; ++i)
        types.push(toType(arguments[i]));

    return new Type(function (value, deep) {
        for (var i = 0; i &#x3c; len; ++i)
            if (types[i].check(value, deep))
                return true;
        return false;
    }, function () {
        return types.join(&#x22; | &#x22;);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x22;null&#x22;: function () { return null },
    &#x22;emptyArray&#x22;: function () { return [] },
    &#x22;false&#x22;: function () { return false },
    &#x22;true&#x22;: function () { return true },
    &#x22;undefined&#x22;: function () {}
};

var naiveIsPrimitive = Type.<span class="apidocCodeKeywordSpan">or</span>(
  builtin.string,
  builtin.number,
  builtin.boolean,
  builtin.null,
  builtin.undefined
);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.Type.prototype" id="apidoc.module.ast-types.Type.prototype">module ast-types.Type.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.Type.prototype.arrayOf" id="apidoc.element.ast-types.Type.prototype.arrayOf">
        function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>arrayOf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayOf = function () {
    var elemType = this;
    return new Type(function (value, deep) {
        return isArray.check(value) &#x26;&#x26; value.every(function (elem) {
              return elemType.check(elem, deep);
          });
    }, function () {
        return &#x22;[&#x22; + elemType + &#x22;]&#x22;;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Type.fromArray = function (arr) {
    if (!isArray.check(arr)) {
        throw new Error(&#x22;&#x22;);
    }
    if (arr.length !== 1) {
        throw new Error(&#x22;only one element type is permitted for typed arrays&#x22;);
    }
    return toType(arr[0]).<span class="apidocCodeKeywordSpan">arrayOf</span>();
};

Tp.arrayOf = function () {
    var elemType = this;
    return new Type(function (value, deep) {
        return isArray.check(value) &#x26;&#x26; value.every(function (elem) {
              return elemType.check(elem, deep);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.prototype.assert" id="apidoc.element.ast-types.Type.prototype.assert">
        function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>assert
        <span class="apidocSignatureSpan">(value, deep)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (value, deep) {
    if (!this.check(value, deep)) {
        var str = shallowStringify(value);
        throw new Error(str + &#x22; does not match type &#x22; + this);
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// rest parameters.
if (!node.rest) {
    return;
}

// For the purposes of this example, we won&#x27;t worry about functions
// with Expression bodies.
n.BlockStatement.<span class="apidocCodeKeywordSpan">assert</span>(node.body);

// Use types.builders to build a variable declaration of the form
//
//   var rest = Array.prototype.slice.call(arguments, n);
//
// where `rest` is the name of the rest parameter, and `n` is a
// numeric literal specifying the number of named parameters the
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.Type.prototype.toString" id="apidoc.element.ast-types.Type.prototype.toString">
        function <span class="apidocSignatureSpan">ast-types.Type.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    var name = this.name;

    if (isString.check(name))
        return name;

    if (isFunction.check(name))
        return name.call(this) + &#x22;&#x22;;

    return name + &#x22; type&#x22;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
} else {
    prefix = &#x22;t$&#x22;;
}

// Include this.depth in the name to make sure the name does not
// collide with any variables in nested/enclosing scopes.
prefix += this.depth.<span class="apidocCodeKeywordSpan">toString</span>(36) + &#x22;$&#x22;;

this.scan();

var index = 0;
while (this.declares(prefix + index)) {
    ++index;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.astNodesAreEquivalent" id="apidoc.module.ast-types.astNodesAreEquivalent">module ast-types.astNodesAreEquivalent</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.astNodesAreEquivalent.astNodesAreEquivalent" id="apidoc.element.ast-types.astNodesAreEquivalent.astNodesAreEquivalent">
        function <span class="apidocSignatureSpan">ast-types.</span>astNodesAreEquivalent
        <span class="apidocSignatureSpan">(a, b, problemPath)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function astNodesAreEquivalent(a, b, problemPath) {
    if (isArray.check(problemPath)) {
        problemPath.length = 0;
    } else {
        problemPath = null;
    }

    return areEquivalent(a, b, problemPath);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.astNodesAreEquivalent.assert" id="apidoc.element.ast-types.astNodesAreEquivalent.assert">
        function <span class="apidocSignatureSpan">ast-types.astNodesAreEquivalent.</span>assert
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assert = function (a, b) {
    var problemPath = [];
    if (!astNodesAreEquivalent(a, b, problemPath)) {
        if (problemPath.length === 0) {
            if (a !== b) {
                throw new Error(&#x22;Nodes must be equal&#x22;);
            }
        } else {
            throw new Error(
              &#x22;Nodes differ in the following path: &#x22; +
              problemPath.map(subscriptForProperty).join(&#x22;&#x22;)
            );
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// rest parameters.
if (!node.rest) {
    return;
}

// For the purposes of this example, we won&#x27;t worry about functions
// with Expression bodies.
n.BlockStatement.<span class="apidocCodeKeywordSpan">assert</span>(node.body);

// Use types.builders to build a variable declaration of the form
//
//   var rest = Array.prototype.slice.call(arguments, n);
//
// where `rest` is the name of the rest parameter, and `n` is a
// numeric literal specifying the number of named parameters the
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ast-types.builders" id="apidoc.module.ast-types.builders">module ast-types.builders</a></h1>


    <h2>
        <a href="#apidoc.element.ast-types.builders.anyTypeAnnotation" id="apidoc.element.ast-types.builders.anyTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>anyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrayExpression" id="apidoc.element.ast-types.builders.arrayExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrayPattern" id="apidoc.element.ast-types.builders.arrayPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrayStatement" id="apidoc.element.ast-types.builders.arrayStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrayTypeAnnotation" id="apidoc.element.ast-types.builders.arrayTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrayTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrowFunctionExpression" id="apidoc.element.ast-types.builders.arrowFunctionExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrowFunctionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.arrowFunctionStatement" id="apidoc.element.ast-types.builders.arrowFunctionStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>arrowFunctionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrowFunctionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.assignmentExpression" id="apidoc.element.ast-types.builders.assignmentExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.assignmentPattern" id="apidoc.element.ast-types.builders.assignmentPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.assignmentStatement" id="apidoc.element.ast-types.builders.assignmentStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>assignmentStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">assignmentStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.awaitExpression" id="apidoc.element.ast-types.builders.awaitExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>awaitExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.awaitStatement" id="apidoc.element.ast-types.builders.awaitStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>awaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awaitStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.binaryExpression" id="apidoc.element.ast-types.builders.binaryExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>binaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.file(&#x22;main.js&#x22;, b.program([
    // Pointless program contents included for extra color.
    b.functionDeclaration(b.identifier(&#x22;succ&#x22;), [
        b.identifier(&#x22;x&#x22;)
    ], b.blockStatement([
        b.returnStatement(
            b.<span class="apidocCodeKeywordSpan">binaryExpression</span>(
                &#x22;+&#x22;, b.identifier(&#x22;x&#x22;), b.literal(1)
            )
        )
    ]))
]));

assert.strictEqual(main.name, &#x22;main.js&#x22;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.binaryStatement" id="apidoc.element.ast-types.builders.binaryStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>binaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.bindExpression" id="apidoc.element.ast-types.builders.bindExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>bindExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.bindStatement" id="apidoc.element.ast-types.builders.bindStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>bindStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.block" id="apidoc.element.ast-types.builders.block">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>block
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">block = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.blockStatement" id="apidoc.element.ast-types.builders.blockStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>blockStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">blockStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
---
```js
var assert = require(&#x22;assert&#x22;);
var n = require(&#x22;ast-types&#x22;).namedTypes;
var b = require(&#x22;ast-types&#x22;).builders;

var fooId = b.identifier(&#x22;foo&#x22;);
var ifFoo = b.ifStatement(fooId, b.<span class="apidocCodeKeywordSpan">blockStatement</span>([
    b.expressionStatement(b.callExpression(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.booleanLiteral" id="apidoc.element.ast-types.builders.booleanLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.booleanLiteralStatement" id="apidoc.element.ast-types.builders.booleanLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.booleanLiteralTypeAnnotation" id="apidoc.element.ast-types.builders.booleanLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.booleanTypeAnnotation" id="apidoc.element.ast-types.builders.booleanTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>booleanTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">booleanTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.breakStatement" id="apidoc.element.ast-types.builders.breakStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>breakStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">breakStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.callExpression" id="apidoc.element.ast-types.builders.callExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>callExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var assert = require(&#x22;assert&#x22;);
var n = require(&#x22;ast-types&#x22;).namedTypes;
var b = require(&#x22;ast-types&#x22;).builders;

var fooId = b.identifier(&#x22;foo&#x22;);
var ifFoo = b.ifStatement(fooId, b.blockStatement([
    b.expressionStatement(b.<span class="apidocCodeKeywordSpan">callExpression</span>(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));

assert.ok(n.BlockStatement.check(ifFoo.consequent));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.callStatement" id="apidoc.element.ast-types.builders.callStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>callStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">callStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.catchClause" id="apidoc.element.ast-types.builders.catchClause">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>catchClause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchClause = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classBody" id="apidoc.element.ast-types.builders.classBody">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classBody
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classBody = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classDeclaration" id="apidoc.element.ast-types.builders.classDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classExpression" id="apidoc.element.ast-types.builders.classExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classImplements" id="apidoc.element.ast-types.builders.classImplements">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classImplements
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classImplements = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classMethod" id="apidoc.element.ast-types.builders.classMethod">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classProperty" id="apidoc.element.ast-types.builders.classProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classPropertyDefinition" id="apidoc.element.ast-types.builders.classPropertyDefinition">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classPropertyDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classPropertyDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.classStatement" id="apidoc.element.ast-types.builders.classStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>classStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">classStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.commentBlock" id="apidoc.element.ast-types.builders.commentBlock">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>commentBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.commentLine" id="apidoc.element.ast-types.builders.commentLine">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>commentLine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">commentLine = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.comprehensionBlock" id="apidoc.element.ast-types.builders.comprehensionBlock">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionBlock
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionBlock = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.comprehensionExpression" id="apidoc.element.ast-types.builders.comprehensionExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.comprehensionStatement" id="apidoc.element.ast-types.builders.comprehensionStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>comprehensionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">comprehensionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.conditionalExpression" id="apidoc.element.ast-types.builders.conditionalExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>conditionalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.conditionalStatement" id="apidoc.element.ast-types.builders.conditionalStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>conditionalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">conditionalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.continueStatement" id="apidoc.element.ast-types.builders.continueStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>continueStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">continueStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.debuggerStatement" id="apidoc.element.ast-types.builders.debuggerStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>debuggerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">debuggerStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareClass" id="apidoc.element.ast-types.builders.declareClass">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareClass
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareClass = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareExportAllDeclaration" id="apidoc.element.ast-types.builders.declareExportAllDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareExportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareExportDeclaration" id="apidoc.element.ast-types.builders.declareExportDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareExportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareExportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareFunction" id="apidoc.element.ast-types.builders.declareFunction">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareFunction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareFunction = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareInterface" id="apidoc.element.ast-types.builders.declareInterface">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareInterface = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareModule" id="apidoc.element.ast-types.builders.declareModule">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareModule
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModule = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareModuleExports" id="apidoc.element.ast-types.builders.declareModuleExports">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareModuleExports
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareModuleExports = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareTypeAlias" id="apidoc.element.ast-types.builders.declareTypeAlias">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareTypeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareTypeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.declareVariable" id="apidoc.element.ast-types.builders.declareVariable">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>declareVariable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">declareVariable = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.decorator" id="apidoc.element.ast-types.builders.decorator">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>decorator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.directive" id="apidoc.element.ast-types.builders.directive">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>directive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directive = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.directiveLiteral" id="apidoc.element.ast-types.builders.directiveLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>directiveLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.directiveLiteralStatement" id="apidoc.element.ast-types.builders.directiveLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>directiveLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">directiveLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.doExpression" id="apidoc.element.ast-types.builders.doExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>doExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.doStatement" id="apidoc.element.ast-types.builders.doStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>doStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.doWhileStatement" id="apidoc.element.ast-types.builders.doWhileStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>doWhileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doWhileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.emptyStatement" id="apidoc.element.ast-types.builders.emptyStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>emptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.emptyTypeAnnotation" id="apidoc.element.ast-types.builders.emptyTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>emptyTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.existentialTypeParam" id="apidoc.element.ast-types.builders.existentialTypeParam">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>existentialTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existentialTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.existsTypeAnnotation" id="apidoc.element.ast-types.builders.existsTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>existsTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">existsTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportAllDeclaration" id="apidoc.element.ast-types.builders.exportAllDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportAllDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportAllDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportBatchSpecifier" id="apidoc.element.ast-types.builders.exportBatchSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportBatchSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportBatchSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportDeclaration" id="apidoc.element.ast-types.builders.exportDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportDefaultDeclaration" id="apidoc.element.ast-types.builders.exportDefaultDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDefaultDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportDefaultSpecifier" id="apidoc.element.ast-types.builders.exportDefaultSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportNamedDeclaration" id="apidoc.element.ast-types.builders.exportNamedDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportNamedDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamedDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportNamespaceSpecifier" id="apidoc.element.ast-types.builders.exportNamespaceSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.exportSpecifier" id="apidoc.element.ast-types.builders.exportSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>exportSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.expressionStatement" id="apidoc.element.ast-types.builders.expressionStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>expressionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">expressionStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```js
var assert = require(&#x22;assert&#x22;);
var n = require(&#x22;ast-types&#x22;).namedTypes;
var b = require(&#x22;ast-types&#x22;).builders;

var fooId = b.identifier(&#x22;foo&#x22;);
var ifFoo = b.ifStatement(fooId, b.blockStatement([
    b.<span class="apidocCodeKeywordSpan">expressionStatement</span>(b.callExpression(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));

assert.ok(n.BlockStatement.check(ifFoo.consequent));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.file" id="apidoc.element.ast-types.builders.file">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>file
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">file = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Prevent further modifications to the File type (and any other
// types newly introduced by def(...)).
types.finalize();

// The b.file builder function is now available. It expects two
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.<span class="apidocCodeKeywordSpan">file</span>(&#x22;main.js&#x22;, b.program([
// Pointless program contents included for extra color.
b.functionDeclaration(b.identifier(&#x22;succ&#x22;), [
    b.identifier(&#x22;x&#x22;)
], b.blockStatement([
    b.returnStatement(
        b.binaryExpression(
            &#x22;+&#x22;, b.identifier(&#x22;x&#x22;), b.literal(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.forAwaitStatement" id="apidoc.element.ast-types.builders.forAwaitStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>forAwaitStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forAwaitStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.forInStatement" id="apidoc.element.ast-types.builders.forInStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>forInStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forInStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.forOfStatement" id="apidoc.element.ast-types.builders.forOfStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>forOfStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forOfStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.forStatement" id="apidoc.element.ast-types.builders.forStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>forStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.functionDeclaration" id="apidoc.element.ast-types.builders.functionDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>functionDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// types newly introduced by def(...)).
types.finalize();

// The b.file builder function is now available. It expects two
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.file(&#x22;main.js&#x22;, b.program([
// Pointless program contents included for extra color.
b.<span class="apidocCodeKeywordSpan">functionDeclaration</span>(b.identifier(&#x22;succ&#x22;), [
    b.identifier(&#x22;x&#x22;)
], b.blockStatement([
    b.returnStatement(
        b.binaryExpression(
            &#x22;+&#x22;, b.identifier(&#x22;x&#x22;), b.literal(1)
        )
    )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.functionExpression" id="apidoc.element.ast-types.builders.functionExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>functionExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.functionStatement" id="apidoc.element.ast-types.builders.functionStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>functionStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.functionTypeAnnotation" id="apidoc.element.ast-types.builders.functionTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>functionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.functionTypeParam" id="apidoc.element.ast-types.builders.functionTypeParam">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>functionTypeParam
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">functionTypeParam = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.generatorExpression" id="apidoc.element.ast-types.builders.generatorExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>generatorExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.generatorStatement" id="apidoc.element.ast-types.builders.generatorStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>generatorStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">generatorStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.genericTypeAnnotation" id="apidoc.element.ast-types.builders.genericTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>genericTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">genericTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.graphExpression" id="apidoc.element.ast-types.builders.graphExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>graphExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.graphIndexExpression" id="apidoc.element.ast-types.builders.graphIndexExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>graphIndexExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.graphIndexStatement" id="apidoc.element.ast-types.builders.graphIndexStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>graphIndexStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphIndexStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.graphStatement" id="apidoc.element.ast-types.builders.graphStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>graphStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.identifier" id="apidoc.element.ast-types.builders.identifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>identifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Basic Usage
---
```js
var assert = require(&#x22;assert&#x22;);
var n = require(&#x22;ast-types&#x22;).namedTypes;
var b = require(&#x22;ast-types&#x22;).builders;

var fooId = b.<span class="apidocCodeKeywordSpan">identifier</span>(&#x22;foo&#x22;);
var ifFoo = b.ifStatement(fooId, b.blockStatement([
    b.expressionStatement(b.callExpression(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.identifierStatement" id="apidoc.element.ast-types.builders.identifierStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>identifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">identifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.ifStatement" id="apidoc.element.ast-types.builders.ifStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>ifStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ifStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
---
```js
var assert = require(&#x22;assert&#x22;);
var n = require(&#x22;ast-types&#x22;).namedTypes;
var b = require(&#x22;ast-types&#x22;).builders;

var fooId = b.identifier(&#x22;foo&#x22;);
var ifFoo = b.<span class="apidocCodeKeywordSpan">ifStatement</span>(fooId, b.blockStatement([
    b.expressionStatement(b.callExpression(fooId, []))
]));

assert.ok(n.IfStatement.check(ifFoo));
assert.ok(n.Statement.check(ifFoo));
assert.ok(n.Node.check(ifFoo));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.import" id="apidoc.element.ast-types.builders.import">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>import
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">import = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.importDeclaration" id="apidoc.element.ast-types.builders.importDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>importDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.importDefaultSpecifier" id="apidoc.element.ast-types.builders.importDefaultSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>importDefaultSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importDefaultSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.importNamespaceSpecifier" id="apidoc.element.ast-types.builders.importNamespaceSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>importNamespaceSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importNamespaceSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.importSpecifier" id="apidoc.element.ast-types.builders.importSpecifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>importSpecifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importSpecifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.importStatement" id="apidoc.element.ast-types.builders.importStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>importStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">importStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.interfaceDeclaration" id="apidoc.element.ast-types.builders.interfaceDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>interfaceDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.interfaceExtends" id="apidoc.element.ast-types.builders.interfaceExtends">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>interfaceExtends
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interfaceExtends = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.intersectionTypeAnnotation" id="apidoc.element.ast-types.builders.intersectionTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>intersectionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">intersectionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxAttribute" id="apidoc.element.ast-types.builders.jsxAttribute">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxClosingElement" id="apidoc.element.ast-types.builders.jsxClosingElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxClosingElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxClosingElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxElement" id="apidoc.element.ast-types.builders.jsxElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxElementStatement" id="apidoc.element.ast-types.builders.jsxElementStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxElementStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxElementStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxEmptyExpression" id="apidoc.element.ast-types.builders.jsxEmptyExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxEmptyExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxEmptyStatement" id="apidoc.element.ast-types.builders.jsxEmptyStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxEmptyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxEmptyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxExpressionContainer" id="apidoc.element.ast-types.builders.jsxExpressionContainer">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxExpressionContainer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxExpressionContainerStatement" id="apidoc.element.ast-types.builders.jsxExpressionContainerStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxExpressionContainerStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxExpressionContainerStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxIdentifier" id="apidoc.element.ast-types.builders.jsxIdentifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxIdentifierStatement" id="apidoc.element.ast-types.builders.jsxIdentifierStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxIdentifierStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxIdentifierStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxMemberExpression" id="apidoc.element.ast-types.builders.jsxMemberExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxMemberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxMemberStatement" id="apidoc.element.ast-types.builders.jsxMemberStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxMemberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxMemberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxNamespacedName" id="apidoc.element.ast-types.builders.jsxNamespacedName">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxNamespacedName
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxNamespacedName = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxOpeningElement" id="apidoc.element.ast-types.builders.jsxOpeningElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxOpeningElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxOpeningElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxSpreadAttribute" id="apidoc.element.ast-types.builders.jsxSpreadAttribute">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadAttribute
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadAttribute = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxSpreadChild" id="apidoc.element.ast-types.builders.jsxSpreadChild">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadChild
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadChild = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxSpreadChildStatement" id="apidoc.element.ast-types.builders.jsxSpreadChildStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxSpreadChildStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxSpreadChildStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxText" id="apidoc.element.ast-types.builders.jsxText">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxText
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxText = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.jsxTextStatement" id="apidoc.element.ast-types.builders.jsxTextStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>jsxTextStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jsxTextStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.labeledStatement" id="apidoc.element.ast-types.builders.labeledStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>labeledStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">labeledStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.letExpression" id="apidoc.element.ast-types.builders.letExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>letExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.letStatement" id="apidoc.element.ast-types.builders.letStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>letStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">letStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.line" id="apidoc.element.ast-types.builders.line">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>line
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">line = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.literal" id="apidoc.element.ast-types.builders.literal">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>literal
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literal = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// numeric literal specifying the number of named parameters the
// function takes.
var restVarDecl = b.variableDeclaration(&#x22;var&#x22;, [
    b.variableDeclarator(
        node.rest,
        b.callExpression(sliceExpr, [
            b.identifier(&#x22;arguments&#x22;),
            b.<span class="apidocCodeKeywordSpan">literal</span>(node.params.length)
        ])
    )
]);

// Similar to doing node.body.body.unshift(restVarDecl), except
// that the other NodePath objects wrapping body statements will
// have their indexes updated to accommodate the new statement.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.literalStatement" id="apidoc.element.ast-types.builders.literalStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>literalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">literalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.logicalExpression" id="apidoc.element.ast-types.builders.logicalExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>logicalExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.logicalStatement" id="apidoc.element.ast-types.builders.logicalStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>logicalStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">logicalStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.memberExpression" id="apidoc.element.ast-types.builders.memberExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>memberExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Here&#x27;s a slightly more involved example of transforming `...rest`
parameters into browser-runnable ES5 JavaScript:

```js
var b = types.builders;

// Reuse the same AST structure for Array.prototype.slice.call.
var sliceExpr = b.<span class="apidocCodeKeywordSpan">memberExpression</span>(
b.memberExpression(
    b.memberExpression(
        b.identifier(&#x22;Array&#x22;),
        b.identifier(&#x22;prototype&#x22;),
        false
    ),
    b.identifier(&#x22;slice&#x22;),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.memberStatement" id="apidoc.element.ast-types.builders.memberStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>memberStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.memberTypeAnnotation" id="apidoc.element.ast-types.builders.memberTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>memberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.metaProperty" id="apidoc.element.ast-types.builders.metaProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>metaProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.metaPropertyStatement" id="apidoc.element.ast-types.builders.metaPropertyStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>metaPropertyStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">metaPropertyStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.methodDefinition" id="apidoc.element.ast-types.builders.methodDefinition">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>methodDefinition
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">methodDefinition = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.mixedTypeAnnotation" id="apidoc.element.ast-types.builders.mixedTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>mixedTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mixedTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.newExpression" id="apidoc.element.ast-types.builders.newExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>newExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.newStatement" id="apidoc.element.ast-types.builders.newStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>newStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">newStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.noop" id="apidoc.element.ast-types.builders.noop">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>noop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">noop = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.nullLiteral" id="apidoc.element.ast-types.builders.nullLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.nullLiteralStatement" id="apidoc.element.ast-types.builders.nullLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.nullLiteralTypeAnnotation" id="apidoc.element.ast-types.builders.nullLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>nullLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.nullTypeAnnotation" id="apidoc.element.ast-types.builders.nullTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>nullTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.nullableTypeAnnotation" id="apidoc.element.ast-types.builders.nullableTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>nullableTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nullableTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.numberLiteralTypeAnnotation" id="apidoc.element.ast-types.builders.numberLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>numberLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.numberTypeAnnotation" id="apidoc.element.ast-types.builders.numberTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>numberTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numberTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.numericLiteral" id="apidoc.element.ast-types.builders.numericLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.numericLiteralStatement" id="apidoc.element.ast-types.builders.numericLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.numericLiteralTypeAnnotation" id="apidoc.element.ast-types.builders.numericLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>numericLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">numericLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectExpression" id="apidoc.element.ast-types.builders.objectExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectMethod" id="apidoc.element.ast-types.builders.objectMethod">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectMethod
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectMethod = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectPattern" id="apidoc.element.ast-types.builders.objectPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectProperty" id="apidoc.element.ast-types.builders.objectProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectStatement" id="apidoc.element.ast-types.builders.objectStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectTypeAnnotation" id="apidoc.element.ast-types.builders.objectTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectTypeCallProperty" id="apidoc.element.ast-types.builders.objectTypeCallProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeCallProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeCallProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectTypeIndexer" id="apidoc.element.ast-types.builders.objectTypeIndexer">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeIndexer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeIndexer = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.objectTypeProperty" id="apidoc.element.ast-types.builders.objectTypeProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>objectTypeProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectTypeProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.parenthesizedExpression" id="apidoc.element.ast-types.builders.parenthesizedExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>parenthesizedExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.parenthesizedStatement" id="apidoc.element.ast-types.builders.parenthesizedStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>parenthesizedStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parenthesizedStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.position" id="apidoc.element.ast-types.builders.position">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>position
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">position = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.program" id="apidoc.element.ast-types.builders.program">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>program
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">program = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Prevent further modifications to the File type (and any other
// types newly introduced by def(...)).
types.finalize();

// The b.file builder function is now available. It expects two
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.file(&#x22;main.js&#x22;, b.<span class="apidocCodeKeywordSpan">program</span>([
// Pointless program contents included for extra color.
b.functionDeclaration(b.identifier(&#x22;succ&#x22;), [
    b.identifier(&#x22;x&#x22;)
], b.blockStatement([
    b.returnStatement(
        b.binaryExpression(
            &#x22;+&#x22;, b.identifier(&#x22;x&#x22;), b.literal(1)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.property" id="apidoc.element.ast-types.builders.property">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>property
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">property = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.propertyPattern" id="apidoc.element.ast-types.builders.propertyPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>propertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">propertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.qualifiedTypeIdentifier" id="apidoc.element.ast-types.builders.qualifiedTypeIdentifier">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>qualifiedTypeIdentifier
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">qualifiedTypeIdentifier = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.regExpLiteral" id="apidoc.element.ast-types.builders.regExpLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>regExpLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.regExpLiteralStatement" id="apidoc.element.ast-types.builders.regExpLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>regExpLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">regExpLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.restElement" id="apidoc.element.ast-types.builders.restElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>restElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.restProperty" id="apidoc.element.ast-types.builders.restProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>restProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">restProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.returnStatement" id="apidoc.element.ast-types.builders.returnStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>returnStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">returnStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// The b.file builder function is now available. It expects two
// arguments, as named by .build(&#x22;name&#x22;, &#x22;program&#x22;) above.
var main = b.file(&#x22;main.js&#x22;, b.program([
    // Pointless program contents included for extra color.
    b.functionDeclaration(b.identifier(&#x22;succ&#x22;), [
        b.identifier(&#x22;x&#x22;)
    ], b.blockStatement([
        b.<span class="apidocCodeKeywordSpan">returnStatement</span>(
            b.binaryExpression(
                &#x22;+&#x22;, b.identifier(&#x22;x&#x22;), b.literal(1)
            )
        )
    ]))
]));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.sequenceExpression" id="apidoc.element.ast-types.builders.sequenceExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>sequenceExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.sequenceStatement" id="apidoc.element.ast-types.builders.sequenceStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>sequenceStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sequenceStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.sourceLocation" id="apidoc.element.ast-types.builders.sourceLocation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>sourceLocation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sourceLocation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.spreadElement" id="apidoc.element.ast-types.builders.spreadElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.spreadElementPattern" id="apidoc.element.ast-types.builders.spreadElementPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadElementPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadElementPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.spreadProperty" id="apidoc.element.ast-types.builders.spreadProperty">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadProperty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadProperty = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.spreadPropertyPattern" id="apidoc.element.ast-types.builders.spreadPropertyPattern">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>spreadPropertyPattern
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spreadPropertyPattern = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.stringLiteral" id="apidoc.element.ast-types.builders.stringLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.stringLiteralStatement" id="apidoc.element.ast-types.builders.stringLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.stringLiteralTypeAnnotation" id="apidoc.element.ast-types.builders.stringLiteralTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>stringLiteralTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringLiteralTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.stringTypeAnnotation" id="apidoc.element.ast-types.builders.stringTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>stringTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.super" id="apidoc.element.ast-types.builders.super">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>super
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.superStatement" id="apidoc.element.ast-types.builders.superStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>superStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">superStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.switchCase" id="apidoc.element.ast-types.builders.switchCase">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>switchCase
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchCase = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.switchStatement" id="apidoc.element.ast-types.builders.switchStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>switchStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">switchStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.taggedTemplateExpression" id="apidoc.element.ast-types.builders.taggedTemplateExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>taggedTemplateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.taggedTemplateStatement" id="apidoc.element.ast-types.builders.taggedTemplateStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>taggedTemplateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">taggedTemplateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.templateElement" id="apidoc.element.ast-types.builders.templateElement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>templateElement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateElement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.templateLiteral" id="apidoc.element.ast-types.builders.templateLiteral">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>templateLiteral
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteral = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.templateLiteralStatement" id="apidoc.element.ast-types.builders.templateLiteralStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>templateLiteralStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateLiteralStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.thisExpression" id="apidoc.element.ast-types.builders.thisExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>thisExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Now do some stuff that might rearrange the list, and this replacement
// remains safe:
fifth.replace(newerNode);

// Replace the third element in an array with two new nodes:
path.get(&#x22;elements&#x22;, 2).replace(
    b.identifier(&#x22;foo&#x22;),
    b.<span class="apidocCodeKeywordSpan">thisExpression</span>()
);

// Remove a node and its parent if it would leave a redundant AST node:
//e.g. var t = 1, y =2; removing the `t` and `y` declarators results in `var undefined`.
path.prune(); //returns the closest parent `NodePath`.

// Remove a node from a list of nodes:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.thisStatement" id="apidoc.element.ast-types.builders.thisStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>thisStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.thisTypeAnnotation" id="apidoc.element.ast-types.builders.thisTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>thisTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">thisTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.throwStatement" id="apidoc.element.ast-types.builders.throwStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>throwStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.tryStatement" id="apidoc.element.ast-types.builders.tryStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>tryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tryStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.tupleTypeAnnotation" id="apidoc.element.ast-types.builders.tupleTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>tupleTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tupleTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeAlias" id="apidoc.element.ast-types.builders.typeAlias">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeAlias
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAlias = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeAnnotation" id="apidoc.element.ast-types.builders.typeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeCastExpression" id="apidoc.element.ast-types.builders.typeCastExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeCastExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeCastStatement" id="apidoc.element.ast-types.builders.typeCastStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeCastStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeCastStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeParameter" id="apidoc.element.ast-types.builders.typeParameter">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameter = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeParameterDeclaration" id="apidoc.element.ast-types.builders.typeParameterDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameterDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeParameterInstantiation" id="apidoc.element.ast-types.builders.typeParameterInstantiation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeParameterInstantiation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeParameterInstantiation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.typeofTypeAnnotation" id="apidoc.element.ast-types.builders.typeofTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>typeofTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">typeofTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.unaryExpression" id="apidoc.element.ast-types.builders.unaryExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>unaryExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var consequent = ifStatement.get(&#x27;consequent&#x27;).value;

        if (!consequent &#x26;&#x26; !alternate) {
var testExpressionStatement = b.expressionStatement(testExpression);

ifStatement.replace(testExpressionStatement);
        } else if (!consequent &#x26;&#x26; alternate) {
var negatedTestExpression = b.<span class="apidocCodeKeywordSpan">unaryExpression</span>(&#x27;!&#x27;, testExpression, true);

if (n.UnaryExpression.check(testExpression) &#x26;&#x26; testExpression.operator === &#x27;!&#x27;) {
    negatedTestExpression = testExpression.argument;
}

ifStatement.get(&#x22;test&#x22;).replace(negatedTestExpression);
ifStatement.get(&#x22;consequent&#x22;).replace(alternate);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.unaryStatement" id="apidoc.element.ast-types.builders.unaryStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>unaryStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unaryStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.unionTypeAnnotation" id="apidoc.element.ast-types.builders.unionTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>unionTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unionTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.updateExpression" id="apidoc.element.ast-types.builders.updateExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>updateExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.updateStatement" id="apidoc.element.ast-types.builders.updateStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>updateStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.variableDeclaration" id="apidoc.element.ast-types.builders.variableDeclaration">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>variableDeclaration
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclaration = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Use types.builders to build a variable declaration of the form
//
//   var rest = Array.prototype.slice.call(arguments, n);
//
// where `rest` is the name of the rest parameter, and `n` is a
// numeric literal specifying the number of named parameters the
// function takes.
var restVarDecl = b.<span class="apidocCodeKeywordSpan">variableDeclaration</span>(&#x22;var&#x22;, [
    b.variableDeclarator(
        node.rest,
        b.callExpression(sliceExpr, [
            b.identifier(&#x22;arguments&#x22;),
            b.literal(node.params.length)
        ])
    )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.variableDeclarator" id="apidoc.element.ast-types.builders.variableDeclarator">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>variableDeclarator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">variableDeclarator = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//
//   var rest = Array.prototype.slice.call(arguments, n);
//
// where `rest` is the name of the rest parameter, and `n` is a
// numeric literal specifying the number of named parameters the
// function takes.
var restVarDecl = b.variableDeclaration(&#x22;var&#x22;, [
    b.<span class="apidocCodeKeywordSpan">variableDeclarator</span>(
        node.rest,
        b.callExpression(sliceExpr, [
            b.identifier(&#x22;arguments&#x22;),
            b.literal(node.params.length)
        ])
    )
]);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.voidTypeAnnotation" id="apidoc.element.ast-types.builders.voidTypeAnnotation">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>voidTypeAnnotation
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">voidTypeAnnotation = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.whileStatement" id="apidoc.element.ast-types.builders.whileStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>whileStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">whileStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.withStatement" id="apidoc.element.ast-types.builders.withStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>withStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">withStatement = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.yieldExpression" id="apidoc.element.ast-types.builders.yieldExpression">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>yieldExpression
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldExpression = function () {
    var args = arguments;
    var argc = args.length;
    var built = Object.create(nodePrototype);

    if (!self.finalized) {
        throw new Error(
          &#x22;attempting to instantiate unfinalized type &#x22; +
          self.typeName
        );
    }

    function add(param, i) {
        if (hasOwn.call(built, param))
            return;

        var all = self.allFields;
        if (!hasOwn.call(all, param)) {
            throw new Error(&#x22;&#x22; + param);
        }

        var field = all[param];
        var type = field.type;
        var value;

        if (isNumber.check(i) &#x26;&#x26; i &#x3c; argc) {
            value = args[i];
        } else if (field.defaultFn) {
            // Expose the partially-built object to the default
            // function as its `this` object.
            value = field.defaultFn.call(built);
        } else {
            var message = &#x22;no value or default function given for field &#x22; +
              JSON.stringify(param) + &#x22; of &#x22; + self.typeName + &#x22;(&#x22; +
              self.buildParams.map(function (name) {
                  return all[name];
              }).join(&#x22;, &#x22;) + &#x22;)&#x22;;
            throw new Error(message);
        }

        if (!type.check(value)) {
            throw new Error(
              shallowStringify(value) +
              &#x22; does not match field &#x22; + field +
              &#x22; of type &#x22; + self.typeName
            );
        }

        // TODO Could attach getters and setters here to enforce
        // dynamic type safety.
        built[param] = value;
    }

    self.buildParams.forEach(function (param, i) {
        add(param, i);
    });

    Object.keys(self.allFields).forEach(function (param) {
        add(param); // Use the default value.
    });

    // Make sure that the &#x22;type&#x22; field was filled automatically.
    if (built.type !== self.typeName) {
        throw new Error(&#x22;&#x22;);
    }

    return built;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ast-types.builders.yieldStatement" id="apidoc.element.ast-types.builders.yieldStatement">
        function <span class="apidocSignatureSpan">ast-types.builders.</span>yieldStatement
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">yieldStatement = function () {
    return builders.expressionStatement(wrapped.apply(builders, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
